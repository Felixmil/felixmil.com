{
  "hash": "8fab423d19e857e3dc39f2d20418b032",
  "result": {
    "markdown": "---\ntitle: \"Advent of Code - Day 5: Supply Stacks\"\nsubtitle: \"Fifth day of the advent of code using R\"\ndate: 2022-12-05\ncategories: \"advent of code\"\nformat: \n   html:\n     df-print: paged\neditor: \n  markdown: \n    wrap: 80\n---\n\n\n\n\n\n# Part 1\n## Input\n\n\n### Full\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- readLines(\"input.txt\")\n\nhead(input, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"        [M]     [B]             [N]\" \"[T]     [H]     [V] [Q]         [H]\" \"[Q]     [N]     [H] [W] [T]     [Q]\" \"[V]     [P] [F] [Q] [P] [C]     [R]\"\n [5] \"[C]     [D] [T] [N] [N] [L] [S] [J]\" \"[D] [V] [W] [R] [M] [G] [R] [N] [D]\" \"[S] [F] [Q] [Q] [F] [F] [F] [Z] [S]\" \"[N] [M] [F] [D] [R] [C] [W] [T] [M]\"\n [9] \" 1   2   3   4   5   6   7   8   9 \" \"\"                                   \n```\n:::\n:::\n\n\n## Libraries\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n\n## Code\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Detect where initial state and procedure are separated\nsep <- which(input == \"\")\n\n# Split initial state of boxes with procedure steps\nboxes <- input[1:(sep-2)]\nprocedure <- input[(sep+1):length(input)] %>% \n  str_extract_all(\"\\\\d+\") %>% \n  map(as.integer)\n\n# Count the number of stack to compute the indexes of the relevant character indexes to catch\nstack_number <- max(str_count(string = boxes,\"\\\\w\"))\nboxes_location <- seq(1,(stack_number*4 - 1), by = 4)+1\n\n# Reconstruct stacks in a list of vectors\nstacks <- \n  map(boxes_location, ~ str_sub(boxes, .x, .x)) %>%\n  map(setdiff, c(\"\", \" \")) %>%\n  map(rev)\n\n\n# Launch the simulation\nfor (step in procedure) {\n    \n  qty <- step[1]\n  from <- step[2]\n  to <- step[3]\n  \n  stacks[[to]] <- c(stacks[[to]], rev(tail(stacks[[from]],qty))) # boxes are \n  # moved (they are reversed since the top ones need to be move before lower ones)\n  \n  stacks[[from]] <- stacks[[from]][1:(length(stacks[[from]])-qty)] # moved boxes \n  # are removed from their original stack\n}\n\n\n# We get the top box (last character of stack vector) for each stack\nresult <- unlist(map(stacks, tail, 1))\n```\n:::\n\n\n## Result\n\nThe crates at the top of each stacks are  **FRDSQRRCD**.\n\n# Part 2\n\n## Code\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstacks <- \n  map(boxes_location, ~ str_sub(boxes, .x, .x)) %>%\n  map(setdiff, c(\"\", \" \")) %>%\n  map(rev)\n\n# Launch the simulation\nfor (step in procedure) {\n    \n  qty <- step[1]\n  from <- step[2]\n  to <- step[3]\n  \n  stacks[[to]] <- c(stacks[[to]], tail(stacks[[from]],qty)) # boxes are \n  # moved (they are NOT reversed since its the CrateMover 9001)\n  \n  stacks[[from]] <- stacks[[from]][1:(length(stacks[[from]])-qty)] # moved boxes \n  # are removed from their original stack\n}\n\n\n# We get the top box (last character of stack vector) for each stack\nresult <- unlist(map(stacks, tail, 1))\n```\n:::\n\n\n## Result\n\nThe crates at the top of each stacks are  **HRFTQVWNN**.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../../../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}